<?php
date_default_timezone_set('Europe/Moscow');
$i=0;

//Позитивный и негативный просмотр
/*
	Иногда нужно решить задачу такого типа: найти строку 'aaa' и заменить ее на '!', 
	но только если перед 'aaa' стоит 'x' (при этом 'x' не заменять). 
	Делается это с помощью специальных скобок (?<= ), которые просто смотрят, но не забирают с собой: 
*/
echo '1. ' .preg_replace('#(?<=x)aaa#', '!', 'xaaa baaa'). '<br>';//выведет 'x! baaa'
/*
	Скобки (?<= ) называются позитивный просмотр назад.
	Позитивный - так как 'x' (в нашем случае) должен быть - только тогда произойдет замена.
	Есть и негативный просмотр назад - (?<! ) - он, наоборот, говорит, что чего-то должно не быть: 
*/

echo '2. ' .preg_replace('#(?<!x)aaa#', '!', 'xaaa baaa'). '<br>';//выведет 'xaaa b!'
//Если перед 'aaa' стоит НЕ 'x', тогда заменим на '!':

//Аналогичные операции выполняют позитивный просмотр вперед (?= ) и негативный просмотр вперед (?! ): 
echo '3. ' .preg_replace('#aaa(?=x)#', '!', 'aaax aaab'). '<br>';//выведет 'xaaa b!'
//Если после 'aaa' стоит  'x', тогда заменим на '!':

echo '4. ' .preg_replace('#aaa(?!x)#', '!', 'aaax aaab'). '<br>';//выведет 'aaax !b'
//Если после 'aaa' стоит НЕ 'x', тогда заменим на '!':


//Функция preg_replace_callback
/*
	Иногда бывает нужно выполнять какие-либо операции с карманами. 
	Например, сложить два кармана, внутри которых числа. Или найти все первые буквы 
	слов и сделать их в верхнем регистре.
	В этом нам поможет функция preg_replace_callback(регулярка, 'название функции', где менять), 
	которая похожа на preg_replace, но вторым параметром принимает название функции, 
	которая вернет то, на что заменять.
	Внутри этой функции будут доступны карманы. 
	Задача: даны строки вида '2+3=', нужно заменить их на тоже самое, 
	но после равно - результат сложения '2+3=5'. 
*/
echo '5. ' .preg_replace_callback('#(\d+)\+(\d+)=#', 'sum', '2+3='). '<br>';
function sum($matches){
	$sum = $matches[1]+$matches[2];//получаем сумму 2+3=5
	$result = $matches[0] . $sum;//$matches[0] - это исходная строка '2+3='
	return $result;
}
//В результате выведет '2+3=5'

//Еще функции для работы с регулярками
/*
	preg_quote(строка, [доп. символы]) - экранирует спец. символы регулярных выражений в строке. 
	Зачем это нужно? Например, вы формируете регулярку динамически '#'.$var.'#' - и хотите 
	быть уверенными, что туда не попадут спецсимволы. Иногда полезно.
	Второй параметр нужен для добавления своих символов для экранировки. 
	
	preg_grep(регулярка, массив) – принимает массив, а возвращает массив только с теми элементами, 
	которые подпадают под регулярку. 
	
	preg_split - разбивает строку в массив по регулярному выражению (типа explode, только с регуляркой). 
*/


//Модификаторы
//x – регулярка перестанет учитывать пробелы и можно будет ставить комментарии после решетки # (однострочные): 
//С комментариями намного понятнее (но длиннее):
echo '6. ' .preg_replace('&
	.+? #любой символ один или более раз
	а #потом буква a
	&x', '!', 'строка'). '<br>';
//Внимание: в этом случае решетки в качестве ограничителей использовать нельзя, 
//поэтому здесь стоят амперсанды. 
/*
	Многострочный режим явно задается с помощью модификатора m, а однострочный - с помощью модификатора s.
	
	Многострочный:
	Шляпка ^ соответствует началу каждой подстроки, а $ - концу: 
	$str = '
		^первая подстрока$
		^вторая подстрока$
	';
	Вместо ^ для начала всей строки следует использовать \A, а вместо $ для конца всей строки - \z.
	Точка совпадает с любым символом, за исключением перевода строки 
	(точнее она не совпадает со \n, а со \r совпадает!). 
	
	Однострочный:
	Шляпка ^ соответствует началу всей строки, а $ - концу: 
	$str = '^
		первая подстрока
		вторая подстрока
	$';
	Точка совпадает с любым символом. 
	Внимание!!! По умолчанию функции поиска preg_match и preg_match_all 
	работают в многострочном режиме (будто добавлен модификатор m), 
	а поиска и замены preg_replace - в однострочном (будто добавлен модификатор s)! 
	Исправляйте добавлением соответствующего модификатора (при необходимости). 
	
	i – игнорирование регистра, '#[a-z]#i' - такое теперь найдет и заглавные буквы. 
	
	U – нежадный поиск, все операторы повторений станут нежадными, 
	а '?', наоборот, будет добавлять им жадности. 
	
	u – корректная работа с utf-8, ставьте его, чтобы не было проблем с кириллицей. 
	
	X – если его поставить, то экранировка обычного символа приведет к ошибке. 
	Без него - обычные символы можно экранировать, 
	они все равно будут обозначать сами себя (исключение: цифры, они станут карманами). 
	
	
*/


?>
<!DOCTYPE html>
<html lang="ru">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <title>Регулярные выражения</title>
   
</head>
<body >
	<div class="main">
		<div class="wrapper">

		</div>
	</div>
	<div style="position: fixed; top:90%; left:80%; z-index:9; background: #f9f98c;"><a href="http://theory.phphtml.net/books/php/regular/rabota-s-regulyarnymi-vyrazeniyami-v-php-glava-4.html" target="_blank">Страница учебника</a></div>
</body>
</html>