<?php
date_default_timezone_set('Europe/Moscow');
$i=0;
/*
	Существует также функция preg_match(регулярка, где искать), которая проверяет, 
	есть ли в строке совпадение с регуляркой.

	При этом, если совпадений будет много, - функция найдет только первое и закончит свою работу.

	Поэтому preg_match выводит либо 1, либо 0 (а не true или false) и используется для ответа
	на вопрос 'есть искомое в строке или нет', вернет 1 - значит есть (а сколько раз - неясно), вернет 0 - значит нет. 
*/

echo ++$i.'. '. preg_match('#a+#', 'eee aaa bbb') . '<br>';//выведет 1
//буква 'a' один или более раз. 

echo ++$i.'. '. preg_match('#a+#', 'eee aaa aa bbb') . '<br>';//все равно выведет 1
//Функция все равно вернет один, хотя совпадений на самом деле совпадений два. 

echo ++$i.'. '. preg_match('#a+#', 'eee bbb') . '<br>';//выведет 0
//Функция ничего не нашла - вернет 0. 

//Функция preg_match также может вернуть false в случае какой-либо ошибки.
//Часто данная функция используется для проверки на соответствие регулярному выражению целой строки. 
//Например, мы хотим узнать - данная строка корректный email или нет:
echo ++$i.'. '. preg_match('#^[a-zA-Z-.]+@[a-z]+\.[a-z]{2,3}$#', 'my-mail@mail.ru') . '<br>';
/*
	[a-zA-Z-.]+ маленькие или большие латинские буквы, точка или '-' 1 или более раз, @ потом @, 
	[a-z]+ потом маленькие латинские 1 или более раз, 
	\. потом точка, 
	[a-z]{2,3} потом маленькие латинские два или три раза (ru, by, com и т.п.). 
	В результате мы получим 1 - наша строка будет корректным емэйлом. 
*/

//preg_match_all(регулярка, где искать, найденное): 
echo ++$i.'. '. preg_match_all('#a+#', 'eee bbb', $m) . '<br>';//выведет 0
echo ++$i.'. '. preg_match_all('#a+#', 'eee aaa bbb', $m) . '<br>';//выведет 1
echo ++$i.'. '. preg_match_all('#a+#', 'eee aaa aa bbb', $m) . '<br>';//выведет 2
var_dump($m);
echo '<br>';
//Функция preg_match_all имеет третий параметр: туда можно записать переменную,
//к которую сложатся все найденные совпадения (в виде массива): 
echo ++$i.'. '. preg_match_all('#a+#', 'eee aaa aa bbb a',  $matches) . '<br>';//выведет 3
var_dump($matches);
echo  '<br>';
//Карманы

/*Мы с вами использовали круглые скобки ( ) для группировки, 
однако они имеют еще одно очень важно применение - используются в качестве карманов. */
echo ++$i.'. '. preg_match_all('#x(a+)x#', 'xax xaax xaaax', $matches) . '<br>';//выведет 3
/*Шаблон поиска такой: буква 'x', затем 'a' один или более раз, затем буква 'x'. 
А то, что стоит в ( ), ложится в карман - и занесется в массив $matches: 
	$matches=[
		0=>[0=>'xax', 1=>'xaax', 2=>'xaaax'], //это найденные подстроки
		1=>[0=>'a', 1=>'aa', 2=>'aaa'] //это содержимое кармана
	]
	То есть карман - это такой способ хранения части того, что мы ищем. 
	Например, мы ищем домены вида domain.ru, но хотим узнать только доменную зону (ru, com и т.п.). 
*/
echo ++$i.'. '. preg_match_all('#[a-z]+\.([a-z]{2,3})#', 'domain.ru site.com hello.by', $matches) . '<br>';
/*
	Шаблон поиска такой: [a-z]+ - маленькие буквы один или более раз (domain, site и т.п.) 
	\. - точка ([a-z]{2,3}) - маленькие буквы 2 или 3 раза (ru, com, by, net и т.п.)
	Посмотрим содержимое $matches: 
		[
			0=>[0=>'domain.ru', 1=>'site.com', 2=>'hello.by'],
			1=>[0=>'ru', 1=>'com', 2=>'by'] //это содержимое кармана
		]
		Можно использовать не один карман, а несколько. Положим в первый карман имя домена, а во второй - зону: 
*/
echo ++$i.'. '. preg_match_all('#([a-z]+)\.([a-z]{2,3})#', 'domain.ru site.com hello.by', $matches) . '<br>';
var_dump($matches);
echo '<br>';
/*
	[
		0=>[0=>'domain.ru', 1=>'site.com', 2=>'hello.by'], //это найденные строки
		1=>[0=>'domain', 1=>'site', 2=>'hello'], //это 1-ый карман
		2=>[0=>'ru', 1=>'com', 2=>'by'], //это 2-ой карман
	]
	Карманы нумеруются по порядку в регулярке: '#([a-z]+)\.([a-z]{2,3})#' - 
	первые круглые скобки - первый карман, вторые - второй карман и так далее. 
	По умолчанию preg_match_all складывает найденные строки в один подмассив, 1-ый карман в другой и так далее.
	Это поведение можно изменить (иногда это очень нужно) с помощью 4-го параметра функции.
*/

//Карманы внутри preg_replace
/*
Карманы можно использовать и при работе с функцией preg_replace - то, 
что мы положим в карман, затем может быть использовано во втором параметре: 
preg_replace(регулярка с карманом, на что заменить, где заменить).

Если мы что-то положим в карман в регулярке, то в параметре 'на что заменить' 
мы можем обратиться к этому карману так: $1 – первый карман, $2 второй карман и так далее.

Давайте решим следующую задачу: даны строки вида 'aaa@bbb' - буквы, потом собака, потом буквы. 
Нужно поменять местами буквы до @ и после. В нашем случае из 'aaa@bbb' сделать 'bbb@aaa': 
*/
echo ++$i.'. '. preg_replace('#([a-z]+)@([a-z]+)#', '$2@$1', 'a@b aa@bb') . '<br>';
/*
Шаблон поиска такой: маленькие буквы один или более раз (первый карман), 
собака, и опять маленькие буквы один или более раз (второй карман).

Шаблон замены такой: мы говорим: замени найденное на $2@$1, где $2 – содержимое второго кармана, а $1 - первого.

Давайте разберем подстроку 'a@b', что с ней происходит: 
'a' ложится в первый карман и доступно как $1, 'b' ложится во второй карман и доступно как $2.

При замене $2@$1 мы говорим: $2 (вставится 'b'), собака @, $1 (вставится 'a'). 
Карман $0 соответствует всему выражению. Давайте заменим подстроки из букв на них самих с '!' по краям: 
*/
echo ++$i.'. '. preg_replace('#[a-z]+#', '!$0!', 'aaa bbb') . '<br>';//выведет '!aaa! !bbb!'
/*
!$0! - $0 это найденная строка (сначала 'aaa', потом 'bbb'). Мы говорим: замени 'aaa' на ее саму 
($0), но с '!' по краям !$0!. И получаем '!aaa!'. Для 'bbb' аналогично. 
*/

//Карманы внутри регулярки
//Карманы можно использовать и внутри самой регулярки: \1 – первый карман, \2 – второй, и так далее. 
echo ++$i.'. '. preg_replace('#([a-z])\1#', '!', 'aaebbc') . '<br>';//выведет '!e!c'
/*
Как это работает: команда [a-z] ищет букву, при этом найденная буква ложится в карман. 
Затем в регулярке стоит \1, который говорит, что после первой буквы должно идти 
содержимое первого кармана (а в нем лежит первая буква).
Таким образом, мы найдем две идущие подряд одинаковые буквы и заменим на '!'. 
*/

//Несохраняющие скобки
//(?:a+) - группируют, но не ложат в карман: 
echo ++$i.'. '. preg_replace('#(?:ab)+([a-z])#', '!$1!', 'ababx abe') . '<br>';//выведет '!x! !e!'
/*
	Шаблон поиска следующий: 'ab' один или более раз, затем одна буква, которую ложим в карман. 
	Шаблон замены: заменим найденное на первый карман, обернутый '!' справа и слева. 
	Так как первый карман - это ([a-z]), то в него попадет сначала 'x', а потом 'e'. 
*/

?>
<!DOCTYPE html>
<html lang="ru">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1">
   <title>Регулярные выражения</title>
   
</head>
<body >
	<div class="main">
		<div class="wrapper">

		</div>
	</div>
	<div style="position: fixed; top:90%; left:80%; z-index:9; background: #f9f98c;"><a href="http://theory.phphtml.net/books/php/regular/rabota-s-regulyarnymi-vyrazeniyami-v-php-glava-3.html" target="_blank">Страница учебника</a></div>
</body>
</html>